DEBUG=${DEBUG:-false}
#DEBUG=${DEBUG:-true}
if $DEBUG; then
    echo "-------------------------" >> ~/tmp/loginpaths.txt
    echo "zshrc> Start of execution" >> ~/tmp/loginpaths.txt
    echo "zshrc> PATH: ${PATH}" >> ~/tmp/loginpaths.txt
    echo "zshrc> path: ${path}" >> ~/tmp/loginpaths.txt
fi

if [ -d ${HOME}/miniconda/envs/py36 ]; then
    conda activate py36
fi

# begin section 1
# This first section adapted from https://www.outcoldman.com/en/archive/2015/09/13/keep-your-sh-together/

# If I see that zsh takes to much time to load I profile what has been changed,
# I want to see my shell ready in not more than 1 second
PROFILING=${PROFILING:-false}
#PROFILING=${PROFILING:-true}
if $PROFILING; then
    zmodload zsh/zprof
fi

# Location of my dotfiles
DOTFILES=$HOME/.dotfiles


# Speed up load time
DISABLE_UPDATE_PROMPT=true

# Execute code in the background to not affect the current session
{
    # Compile zcompdump, if modified, to increase startup speed.
    zcompdump="${ZDOTDIR:-$HOME}/.zcompdump"
    if [[ -s "$zcompdump" && (! -s "${zcompdump}.zwc" || "$zcompdump" -nt "${zcompdump}.zwc") ]]; then
        zcompile "$zcompdump"
    fi
} &!

# Perform compinit only once a day
autoload -Uz compinit
# if [ $(date +'%j') != $(stat -f '%Sm' -t '%j' ~/.zcompdump) ]; then
if [[ -n ${ZDOTDIR}/.zcompdump(#qN.mh+24) ]]; then
  compinit
else
  compinit -C
fi

# Perform compinit only once a day
# autoload -Uz compinit

# setopt EXTENDEDGLOB
# for dump in $ZSH_COMPDUMP(#qN.m1); do
#     compinit
#     if [[ -s "$dump" && (! -s "$dump.zwc" || "$dump" -nt "$dump.zwc") ]]; then
#         zcompile "$dump"
#     fi
#     echo "Initializing Completions..."
# done
# unsetopt EXTENDEDGLOB
# compinit -C

# if you want red dots to be displayed while waiting for completion
COMPLETION_WAITING_DOTS="true"

# tmux plugin settings
ZSH_TMUX_AUTOSTART_ONCE=true
ZSH_TMUX_FIXTERM=true
ZSH_TMUX_AUTOQUIT=false # tells TMUX not to close terminal once tmux exits

# set DEFAULT_USER based on ${USERNAME} variable
DEFAULT_USER=${USERNAME}

# end section 1

# use vi bindings
bindkey -v

# Uncomment the following line to use case-sensitive completion.
CASE_SENSITIVE="true"

# Uncomment the following line to disable auto-setting terminal title.
DISABLE_AUTO_TITLE="true"

# Uncomment the following line to enable command auto-correction.
# ENABLE_CORRECTION="true"

# User configuration

# ssh
# #export SSH_KEY_PATH="~/.ssh/rsa_id"

## Powerlevel9k Settings
POWERLEVEL9K_HISTORY_BACKGROUND='green'

POWERLEVEL9K_PROMPT_ON_NEWLINE=true

POWERLEVEL9K_MULTILINE_FIRST_PROMPT_PREFIX=''
POWERLEVEL9K_MULTILINE_SECOND_PROMPT_PREFIX="%F{red} \Uf1d0 %f %F{yellow}❯ "

POWERLEVEL9K_PROMPT_ON_NEWLINE=true
POWERLEVEL9K_RPROMPT_ON_NEWLINE=false

POWERLEVEL9K_DIR_OMIT_FIRST_CHARACTER=false
POWERLEVEL9K_ALWAYS_SHOW_CONTEXT=false
POWERLEVEL9K_CONTEXT_ALWAYS_SHOW_USER=false
POWERLEVEL9K_ALWAYS_SHOW_USER=false
POWERLEVEL9K_CONTEXT_ROOT_BACKGROUND=red
POWERLEVEL9K_CONTEXT_ROOT_FOREGROUND=black

# Command prompt
POWERLEVEL9K_LEFT_PROMPT_ELEMENTS=(vcs custom_git_repo_name newline context dir custom_direnv_active )
POWERLEVEL9K_RIGHT_PROMPT_ELEMENTS=(status anaconda root_indicator vi_mode date ssh)

# GitHub prompt
POWERLEVEL9K_VCS_GIT_GITHUB_ICON=$'\uF113'

get_repo_name() {
    echo -n $GITREPO
}

direnv_active() {
    if [[ -n "$DIRENV_DIFF" ]]; then
        local color='%F{blue}'
        echo -n "\uf300"
    fi
}

# Custom segment configs
POWERLEVEL9K_CUSTOM_GIT_REPO_NAME="get_repo_name"
POWERLEVEL9K_CUSTOM_DIRENV_ACTIVE="direnv_active"
POWERLEVEL9K_CUSTOM_DIRENV_ACTIVE_FOREGROUND="black"
POWERLEVEL9K_CUSTOM_DIRENV_ACTIVE_BACKGROUND="green"

# dir
POWERLEVEL9K_HOME_ICON="\uf016"
POWERLEVEL9K_HOME_SUB_ICON="\uf07c"
POWERLEVEL9K_FOLDER_ICON="\uf07b"
POWERLEVEL9K_ETC_ICON="\uf423"
POWERLEVEL9K_SHORTEN_DIR_LENGTH=2
# POWERLEVEL9K_SHORTEN_STRATEGY='truncate_to_first_and_last'
POWERLEVEL9K_SHORTEN_STRATEGY='truncate_with_package_name'
POWERLEVEL9K_DIR_PACKAGE_FILES=(package.json composer.json)
POWERLEVEL9K_DIR_SHOW_WRITABLE=true

POWERLEVEL9K_STATUS_VERBOSE=true
POWERLEVEL9K_STATUS_CROSS=false
POWERLEVEL9K_STATUS_OK=false

# anaconda segment
POWERLEVEL9K_ANACONDA_LEFT_DELIMITER="\uE235 "
POWERLEVEL9K_ANACONDA_RIGHT_DELIMITER=""
POWERLEVEL9K_ANACONDA_BACKGROUND='cyan'
POWERLEVEL9K_ANACONDA_FOREGROUND='black'
# POWERLEVEL9K_PYTHON_ICON="\uf81f"

# load powerlevel9k theme
source ${DOTFILES}/themes/powerlevel9k/powerlevel9k.zsh-theme
POWERLEVEL9K_MODE='awsome-patched'
ZSH_THEME="powerlevel9k/powerlevel9k"

# dumb terminal can be a vim dump terminal in that case don't try to load plugins
if [ ! $TERM = dumb ]; then
    ZGEN_DIR=${HOME}/.zgen
    source ${DOTFILES}/plugins/autojump/autojump.plugin.zsh
    source ${DOTFILES}/plugins/my-aliases/my-aliases.plugin.zsh
    # source ${DOTFILES}/plugins/my-brew/my-brew.plugin.zsh
    source ${DOTFILES}/plugins/my-tmux/my-tmux.plugin.zsh
    source ${DOTFILES}/plugins/sudo/sudo.plugin.zsh
    # source ${DOTFILES}/plugins/taskwarrior/taskwarrior.plugin.zsh
    source ${DOTFILES}/plugins/tmuxinator/tmuxinator.plugin.zsh
    source ${DOTFILES}/plugins/tpm/tpm.plugin.zsh
    # source ${DOTFILES}/plugins/vi-mode/vi-mode.plugin.zsh
    source ${DOTFILES}/plugins/vundle/vundle.plugin.zsh
    source ${DOTFILES}/plugins/zsh-autosuggestions/zsh-autosuggestions.plugin.zsh
    # source ${DOTFILES}/plugins/zsh-completions/zsh-completions.plugin.zsh
fi

# Which plugins would you like to load?
# plugins=(sudo git my-tmux my-aliases taskwarrior tmux tmuxinator zsh-autosuggestions tpm)
# plugins=(sudo git my-tmux my-aliases tmux tmuxinator zsh-autosuggestions tpm)


test -e "${HOME}/.iterm2_shell_integration.zsh" && source "${HOME}/.iterm2_shell_integration.zsh"

# additional configuration for zsh
# Remove the history (fc -l) command from the history list when invoked.
setopt histnostore
# Remove superfluous blanks from each command line being added to the history list.
setopt histreduceblanks
# Do not exit on end-of-file. Require the use of exit or logout instead.
# setopt ignoreeof
# Print the exit value of programs with non-zero exit status.
# setopt printexitvalue
# Do not share history
# setopt no_share_history

# load local tmux configurations
tmux source-file ~/.tmux-local.conf

# specific for machine configuration, which I don't sync
if [ -f ~/.machinerc ]; then
    source ~/.machinerc
fi

# build_ycm() {
#     if [[ -d ${HOME}/.vim/bundle/YouCompleteMe/ ]]; then
#         YCMDIR=${HOME}/.vim/bundle/YouCompleteMe/
#         YCMBUILDDIR=${HOME}/.vim/bundle/YouCompleteMe/third_party/ycmd/ycmd/__pycache__
#     elif [[ -d ${HOME}/.vim/bundle/Vundle.vim/YouCompleteMe/ ]]; then
#         YCMDIR=${HOME}/.vim/bundle/Vundle.vim/YouCompleteMe/
#         YCMBUILDDIR=${HOME}/.vim/bundle/Vundle.vim/YouCompleteMe/third_party/ycmd/ycmd/__pycache__
#     fi
#     if [[ ! -d $YCMBUILDDIR ]]; then
#         print -P "%B%K{green}%F{black}[*]%k%f%b Building the YouCompleteMe core library."
#         if [ ! -f "$YCMDIR/third_party/ycmd/third_party/cregex/regex_3/_regex.so" ]; then
#             cd ${YCMDIR}
#             if $(python install.py > ${HOME}/dotfiles-installer.out); then
#                 print -P "%B%K{green}%F{black}[*]%f%k%b Success!"
#             else
#                 print -P "%B%K{red}%F{black}[X]%f%k%b Install failed."
#                 exit(1)
#             fi
#             cd -
#         fi
#     else
#         print -P "%B%K{green}%F{black}[*]%f%k%b YouCompleteMe core already built."
#     fi
# }


# rebuild_ycm() {
#     if [[ -d ${HOME}/.vim/bundle/YouCompleteMe/ ]]; then
#         YCMDIR=${HOME}/.vim/bundle/YouCompleteMe/
#         YCMBUILDDIR=${HOME}/.vim/bundle/YouCompleteMe/third_party/ycmd/ycmd/__pycache__
#     elif [[ -d ${HOME}/.vim/bundle/Vundle.vim/YouCompleteMe/ ]]; then
#         YCMDIR=${HOME}/.vim/bundle/Vundle.vim/YouCompleteMe/
#         YCMBUILDDIR=${HOME}/.vim/bundle/Vundle.vim/YouCompleteMe/third_party/ycmd/ycmd/__pycache__
#     fi
#     if [[ ! -d $YCMBUILDDIR ]]; then
#         print -P "%B%K{green}%F{black}[*]%k%f%b Building the YouCompleteMe core library."
#         if [ ! -f "$YCMDIR/third_party/ycmd/third_party/cregex/regex_3/_regex.so" ]; then
#             cd ${YCMDIR}
#             if $(python install.py > ${HOME}/dotfiles-installer.out); then
#                 print -P "%B%K{green}%F{black}[*]%f%k%b Success!"
#             else
#                 print -P "%B%K{red}%F{black}[X]%f%k%b Install failed."
#                 exit(1)
#             fi
#             cd -
#         fi
#     else
#         print -P "%B%K{green}%F{black}[*]%k%f%b Building the YouCompleteMe core library."
#         rm -rf $YCMBUILDDIR
#         if [ ! -f "$YCMDIR/third_party/ycmd/third_party/cregex/regex_3/_regex.so" ]; then
#             cd ${YCMDIR}
#             if $(python install.py > ${HOME}/dotfiles-installer.out); then
#                 print -P "%B%K{green}%F{black}[*]%f%k%b Success!"
#             else
#                 print -P "%B%K{red}%F{black}[X]%f%k%b Install failed."
#                 exit(1)
#             fi
#             cd -
#         fi
#     fi
# }

# Switch between different python installations
switch_python() {
    echo "SP Start"
    if [[ $0 == "local" ]]; then
        echo "ARG local"
        PATH=${PATH:s/.+PYTHON/\/usr\/local\/bin:PYTHON/}
    elif [[ $0 == 'conda' ]]; then
        echo "ARG conda"
        if [[ $PATH =~ "anaconda" ]]; then
            echo "Found anaconda in PATH"
            PATH=${PATH:s/.+PYTHON/\/anaconda3\/bin\/:PYTHON/}
        elif [[ $PATH =~ "miniconda3" ]]; then
            echo "Found miniconda3 in PATH"
            PATH=${PATH:s/.+PYTHON/${HOME}\/miniconda3\/bin:PYTHON/}
        else
            echo "Didn't find others, so presuming miniconda"
            PATH=${PATH:s/.+PYTHON/${HOME}\/miniconda\/bin:PYTHON/}}
        fi
    fi
    echo $PATH
    echo $(which python)
}

# Deal with path anomalies across platforms
fix_path() {
    # First get rid of games entries that are cropping up on raspbian and expand tilde
    # since some programs have problems with that directory expansion in PATH
    tmp_path=$(print -l ${(j.:.)$(print -l "${(s. .)path}" |grep -v games)})
    PATH=${PATH:gs/~/(${HOME}|\/usr\/(local|bin)\/games:)/}
    # PATH=${PATH:gs/\/usr\/(local|bin)\/games://}
    unset mimiconda_loc
    # tmp_path=${PATH/\/usr\/local\/games://}
    # tmp_path=${PATH/\/usr\/bin\/games://}
    # echo $tmp_path
    if [[ -d ${HOME}/miniconda ]]; then
        miniconda_loc=miniconda
    elif [[ -d ${HOME}/miniconda3 ]]; then
        miniconda_loc=miniconda3
    elif [[ -d /anaconda3 && ! ${PATH} =~ /anaconda/ ]]; then
        PATH=/anaconda3/bin:${tmp_path}
    fi
    if [ ${miniconda_loc} ]; then
        if [[ ${PATH} =~ /anaconda/ ]]; then
            PATH=$(echo ${PATH} |sed 's/\/anaconda3/${HOME}\/${miniconda_loc}\/PYTHON')
        elif [[ ! ${PATH} =~ /miniconda/ ]]; then
            PATH=${HOME}/${miniconda_loc}/bin:PYTHON:${PATH}
        fi
    fi
}

# Attempt to deduplicate the PATH variable
dedup_path() {
    # tmppath=${(j.:.)${(u)path}}
    PATH=${(j.:.)${(u)path}}
}
dedup_path && fix_path

# Load direnv, which hopefully will speed up prompt generation
# export DIRENV_LOG_FORMAT=
# eval "$(direnv hook zsh)"

# if profiling was on
if $PROFILING; then
    zprof
fi

# zsh-syntax-highlighting must be sourced as the last thing in this file
source ~/.dotfiles/plugins/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh
if $DEBUG; then
    echo "zshrc> PATH: ${PATH}" >> ~/tmp/loginpaths.txt
    echo "zshrc> path: ${path}" >> ~/tmp/loginpaths.txt
    echo "zshrc> End of execution" >> ~/tmp/loginpaths.txt
    echo "-------------------------" >> ~/tmp/loginpaths.txt
fi
