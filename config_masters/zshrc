DEBUG=${DEBUG:-false}
# DEBUG=${DEBUG:-true}
if $DEBUG; then
    echo "-------------------------" >> ~/tmp/loginpaths.txt
    echo "zshrc> Start of execution" >> ~/tmp/loginpaths.txt
    echo "zshrc> PATH: ${PATH}" >> ~/tmp/loginpaths.txt
    echo "zshrc> path: ${path}" >> ~/tmp/loginpaths.txt
fi

PROFILING=${PROFILING:-false}
# PROFILING=${PROFILING:-true}

# if profiling is on
if $PROFILING; then
    zprof
fi

export TRY_THEMING=p10k

if [ -d ${HOME}/miniconda/envs/py36 ]; then
    conda activate py36
fi

# begin section 1
# This first section adapted from https://www.outcoldman.com/en/archive/2015/09/13/keep-your-sh-together/

# If I see that zsh takes to much time to load I profile what has been changed,
# I want to see my shell ready in not more than 1 second
PROFILING=${PROFILING:-false}
#PROFILING=${PROFILING:-true}
if $PROFILING; then
    zmodload zsh/zprof
fi

# Location of my dotfiles
DOTFILES=$HOME/.dotfiles


# Speed up load time
DISABLE_UPDATE_PROMPT=true

# Execute code in the background to not affect the current session
{
    # Compile zcompdump, if modified, to increase startup speed.
    zcompdump="${ZDOTDIR:-$HOME}/.zcompdump"
    if [[ -s "$zcompdump" && (! -s "${zcompdump}.zwc" || "$zcompdump" -nt "${zcompdump}.zwc") ]]; then
        zcompile "$zcompdump"
    fi
} &!

# Perform compinit only once a day
autoload -Uz compinit
# if [ $(date +'%j') != $(stat -f '%Sm' -t '%j' ~/.zcompdump) ]; then
if [[ -n ${ZDOTDIR}/.zcompdump(#qN.mh+24) ]]; then
  compinit
else
  compinit -C
fi

# Perform compinit only once a day
# autoload -Uz compinit

# setopt EXTENDEDGLOB
# for dump in $ZSH_COMPDUMP(#qN.m1); do
#     compinit
#     if [[ -s "$dump" && (! -s "$dump.zwc" || "$dump" -nt "$dump.zwc") ]]; then
#         zcompile "$dump"
#     fi
#     echo "Initializing Completions..."
# done
# unsetopt EXTENDEDGLOB
# compinit -C

# if you want red dots to be displayed while waiting for completion
COMPLETION_WAITING_DOTS="true"

# tmux plugin settings
ZSH_TMUX_AUTOSTART_ONCE=true
ZSH_TMUX_FIXTERM=true
ZSH_TMUX_AUTOQUIT=false # tells TMUX not to close terminal once tmux exits

# set DEFAULT_USER based on ${USERNAME} variable
DEFAULT_USER=${USERNAME}

# end section 1

# use vi bindings
bindkey -v

# Uncomment the following line to use case-sensitive completion.
CASE_SENSITIVE="true"

# Uncomment the following line to disable auto-setting terminal title.
DISABLE_AUTO_TITLE="true"

# Uncomment the following line to enable command auto-correction.
# ENABLE_CORRECTION="true"

# User configuration

# ssh
# #export SSH_KEY_PATH="~/.ssh/rsa_id"

[[ ! -f ${HOME}/.theming.zsh ]] || source ~/.theming.zsh

# dumb terminal can be a vim dump terminal in that case don't try to load plugins
if [ ! $TERM = dumb ]; then
    ZGEN_DIR=${HOME}/.zgen
    source ${DOTFILES}/plugins/autojump/autojump.plugin.zsh
    source ${DOTFILES}/plugins/my-aliases/my-aliases.plugin.zsh
    # source ${DOTFILES}/plugins/my-brew/my-brew.plugin.zsh
    source ${DOTFILES}/plugins/my-tmux/my-tmux.plugin.zsh
    source ${DOTFILES}/plugins/sudo/sudo.plugin.zsh
    # source ${DOTFILES}/plugins/taskwarrior/taskwarrior.plugin.zsh
    source ${DOTFILES}/plugins/tmuxinator/tmuxinator.plugin.zsh
    source ${DOTFILES}/plugins/tpm/tpm.plugin.zsh
    # source ${DOTFILES}/plugins/vi-mode/vi-mode.plugin.zsh
    source ${DOTFILES}/plugins/vundle/vundle.plugin.zsh
    source ${DOTFILES}/plugins/zsh-autosuggestions/zsh-autosuggestions.plugin.zsh
    # source ${DOTFILES}/plugins/zsh-completions/zsh-completions.plugin.zsh
fi

# Which plugins would you like to load?
# plugins=(sudo git my-tmux my-aliases taskwarrior tmux tmuxinator zsh-autosuggestions tpm)
# plugins=(sudo git my-tmux my-aliases tmux tmuxinator zsh-autosuggestions tpm)


test -e "${HOME}/.iterm2_shell_integration.zsh" && source "${HOME}/.iterm2_shell_integration.zsh"

# additional configuration for zsh
# Remove the history (fc -l) command from the history list when invoked.
setopt histnostore
# Remove superfluous blanks from each command line being added to the history list.
setopt histreduceblanks
# Do not exit on end-of-file. Require the use of exit or logout instead.
# setopt ignoreeof
# Print the exit value of programs with non-zero exit status.
# setopt printexitvalue
# Do not share history
# setopt no_share_history

# load local tmux configurations
tmux source-file ~/.tmux-local.conf

# specific for machine configuration, which I don't sync
if [ -f ~/.machinerc ]; then
    source ~/.machinerc
fi

# build_ycm() {
#     if [[ -d ${HOME}/.vim/bundle/YouCompleteMe/ ]]; then
#         YCMDIR=${HOME}/.vim/bundle/YouCompleteMe/
#         YCMBUILDDIR=${HOME}/.vim/bundle/YouCompleteMe/third_party/ycmd/ycmd/__pycache__
#     elif [[ -d ${HOME}/.vim/bundle/Vundle.vim/YouCompleteMe/ ]]; then
#         YCMDIR=${HOME}/.vim/bundle/Vundle.vim/YouCompleteMe/
#         YCMBUILDDIR=${HOME}/.vim/bundle/Vundle.vim/YouCompleteMe/third_party/ycmd/ycmd/__pycache__
#     fi
#     if [[ ! -d $YCMBUILDDIR ]]; then
#         print -P "%B%K{green}%F{black}[*]%k%f%b Building the YouCompleteMe core library."
#         if [ ! -f "$YCMDIR/third_party/ycmd/third_party/cregex/regex_3/_regex.so" ]; then
#             cd ${YCMDIR}
#             if $(python install.py > ${HOME}/dotfiles-installer.out); then
#                 print -P "%B%K{green}%F{black}[*]%f%k%b Success!"
#             else
#                 print -P "%B%K{red}%F{black}[X]%f%k%b Install failed."
#                 exit(1)
#             fi
#             cd -
#         fi
#     else
#         print -P "%B%K{green}%F{black}[*]%f%k%b YouCompleteMe core already built."
#     fi
# }


# rebuild_ycm() {
#     if [[ -d ${HOME}/.vim/bundle/YouCompleteMe/ ]]; then
#         YCMDIR=${HOME}/.vim/bundle/YouCompleteMe/
#         YCMBUILDDIR=${HOME}/.vim/bundle/YouCompleteMe/third_party/ycmd/ycmd/__pycache__
#     elif [[ -d ${HOME}/.vim/bundle/Vundle.vim/YouCompleteMe/ ]]; then
#         YCMDIR=${HOME}/.vim/bundle/Vundle.vim/YouCompleteMe/
#         YCMBUILDDIR=${HOME}/.vim/bundle/Vundle.vim/YouCompleteMe/third_party/ycmd/ycmd/__pycache__
#     fi
#     if [[ ! -d $YCMBUILDDIR ]]; then
#         print -P "%B%K{green}%F{black}[*]%k%f%b Building the YouCompleteMe core library."
#         if [ ! -f "$YCMDIR/third_party/ycmd/third_party/cregex/regex_3/_regex.so" ]; then
#             cd ${YCMDIR}
#             if $(python install.py > ${HOME}/dotfiles-installer.out); then
#                 print -P "%B%K{green}%F{black}[*]%f%k%b Success!"
#             else
#                 print -P "%B%K{red}%F{black}[X]%f%k%b Install failed."
#                 exit(1)
#             fi
#             cd -
#         fi
#     else
#         print -P "%B%K{green}%F{black}[*]%k%f%b Building the YouCompleteMe core library."
#         rm -rf $YCMBUILDDIR
#         if [ ! -f "$YCMDIR/third_party/ycmd/third_party/cregex/regex_3/_regex.so" ]; then
#             cd ${YCMDIR}
#             if $(python install.py > ${HOME}/dotfiles-installer.out); then
#                 print -P "%B%K{green}%F{black}[*]%f%k%b Success!"
#             else
#                 print -P "%B%K{red}%F{black}[X]%f%k%b Install failed."
#                 exit(1)
#             fi
#             cd -
#         fi
#     fi
# }

# Switch between different python installations
switch_python() {
    echo "SP Start"
    if [[ $0 == "local" ]]; then
        echo "ARG local"
        PATH=${PATH:s/.+PYTHON/\/usr\/local\/bin:PYTHON/}
    elif [[ $0 == 'conda' ]]; then
        echo "ARG conda"
        if [[ $PATH =~ "anaconda" ]]; then
            echo "Found anaconda in PATH"
            PATH=${PATH:s/.+PYTHON/\/anaconda3\/bin\/:PYTHON/}
        elif [[ $PATH =~ "miniconda3" ]]; then
            echo "Found miniconda3 in PATH"
            PATH=${PATH:s/.+PYTHON/${HOME}\/miniconda3\/bin:PYTHON/}
        else
            echo "Didn't find others, so presuming miniconda"
            PATH=${PATH:s/.+PYTHON/${HOME}\/miniconda\/bin:PYTHON/}}
        fi
    fi
    echo $PATH
    echo $(which python)
}

# Deal with path anomalies across platforms
fix_path() {
    # First get rid of games entries that are cropping up on raspbian and expand tilde
    # since some programs have problems with that directory expansion in PATH
    tmp_path=$(print -l ${(j.:.)$(print -l "${(s. .)path}" |grep -v games)})
    PATH=${PATH:gs/~/(${HOME}|\/usr\/(local|bin)\/games:)/}
    # PATH=${PATH:gs/\/usr\/(local|bin)\/games://}
    unset mimiconda_loc
    # tmp_path=${PATH/\/usr\/local\/games://}
    # tmp_path=${PATH/\/usr\/bin\/games://}
    # echo $tmp_path
    if [[ -d ${HOME}/miniconda ]]; then
        miniconda_loc=miniconda
    elif [[ -d ${HOME}/miniconda3 ]]; then
        miniconda_loc=miniconda3
    elif [[ -d /anaconda3 && ! ${PATH} =~ /anaconda/ ]]; then
        PATH=/anaconda3/bin:${tmp_path}
    fi
    if [ ${miniconda_loc} ]; then
        if [[ ${PATH} =~ /anaconda/ ]]; then
            PATH=$(echo ${PATH} |sed 's/\/anaconda3/${HOME}\/${miniconda_loc}\/PYTHON')
        elif [[ ! ${PATH} =~ /miniconda/ ]]; then
            PATH=${HOME}/${miniconda_loc}/bin:PYTHON:${PATH}
        fi
    fi
}

# Attempt to deduplicate the PATH variable
dedup_path() {
    # tmppath=${(j.:.)${(u)path}}
    PATH=${(j.:.)${(u)path}}
}
# dedup_path && fix_path

# Load direnv, which hopefully will speed up prompt generation
# export DIRENV_LOG_FORMAT=
# eval "$(direnv hook zsh)"

# if profiling was on
if $PROFILING; then
    zprof
fi

# zsh-syntax-highlighting must be sourced as the last thing in this file
source ~/.dotfiles/plugins/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh
if $DEBUG; then
    echo "zshrc> PATH: ${PATH}" >> ~/tmp/loginpaths.txt
    echo "zshrc> path: ${path}" >> ~/tmp/loginpaths.txt
    echo "zshrc> End of execution" >> ~/tmp/loginpaths.txt
    echo "-------------------------" >> ~/tmp/loginpaths.txt
fi

# # >>> conda initialize >>>
# # !! Contents within this block are managed by 'conda init' !!
# __conda_setup="$('/home/hubrigant/miniconda3/bin/conda' 'shell.zsh' 'hook' 2> /dev/null)"
# if [ $? -eq 0 ]; then
#     eval "$__conda_setup"
# else
#     if [ -f "/home/hubrigant/miniconda3/etc/profile.d/conda.sh" ]; then
#         . "/home/hubrigant/miniconda3/etc/profile.d/conda.sh"
#     else
#         export PATH="/home/hubrigant/miniconda3/bin:$PATH"
#     fi
# fi
# unset __conda_setup
# # <<< conda initialize <<<

# instead of using the miniconda loading above immediately
# use a plugin to lazy-load conda
source ${DOTFILES}/plugins/lazy-conda/lazy-conda.plugin.zsh

# fix up the $path list using my path plugin
source ${DOTFILES}/plugins/my-path/my-path.plugin.zsh

[[ ! -f ${HOME}/.zshrc-local ]] || source ~/.zshrc-local
