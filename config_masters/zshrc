if $DEBUG; then
    echo "-------------------------" >> ~/tmp/loginpaths.txt
    echo "zshrc> Start of execution" >> ~/tmp/loginpaths.txt
    echo "zshrc> PATH: ${PATH}" >> ~/tmp/loginpaths.txt
    echo "zshrc> path: ${path}" >> ~/tmp/loginpaths.txt
fi

# begin section 1
# This first section adapted from https://www.outcoldman.com/en/archive/2015/09/13/keep-your-sh-together/

# If I see that zsh takes to much time to load I profile what has been changed,
# I want to see my shell ready in not more than 1 second
PROFILING=${PROFILING:-false}
#PROFILING=${PROFILING:-true}
if $PROFILING; then
    zmodload zsh/zprof
fi

# Location of my dotfiles
DOTFILES=$HOME/.dotfiles


# Speed up load time
DISABLE_UPDATE_PROMPT=true

# Perform compinit only once a day
autoload -Uz compinit

setopt EXTENDEDGLOB
for dump in $ZSH_COMPDUMP(#qN.m1); do
    compinit
    if [[ -s "$dump" && (! -s "$dump.zwc" || "$dump" -nt "$dump.zwc") ]]; then
        zcompile "$dump"
    fi
    echo "Initializing Completions..."
done
unsetopt EXTENDEDGLOB
compinit -C

# if you want red dots to be displayed while waiting for completion
COMPLETION_WAITING_DOTS="true"

# tmux plugin settings
ZSH_TMUX_AUTOSTART_ONCE=false
ZSH_TMUX_FIXTERM=true
ZSH_TMUX_AUTOQUIT=false # tells TMUX not to close terminal once tmux exits

# set DEFAULT_USER based on different environments
# if [[ $OSTYPE =~ 'darwin' ]]; then
#     if [[ `hostname` = 'WDXJW68539TD8' ]]; then
#         DEFAULT_USER=jw68539
#     else
#         DEFAULT_USER=jon
#     fi
# else
#     DEFAULT_USER=pi
# fi

# set DEFAULT_USER based on ${USERNAME} variable
DEFAULT_USER=${USERNAME}

# end section 1

# use vi bindings
bindkey -v
# source ~/.zshenv

# load powerlevel9k theme
source ${DOTFILES}/themes/powerlevel9k/powerlevel9k.zsh-theme
POWERLEVEL9K_MODE='awsome-patched'
ZSH_THEME="powerlevel9k/powerlevel9k"

# Uncomment the following line to use case-sensitive completion.
CASE_SENSITIVE="true"

# Uncomment the following line to disable auto-setting terminal title.
DISABLE_AUTO_TITLE="true"

# Uncomment the following line to enable command auto-correction.
# ENABLE_CORRECTION="true"

# User configuration

# ssh
# #export SSH_KEY_PATH="~/.ssh/rsa_id"

## Powerlevel9k Settings
POWERLEVEL9K_HISTORY_BACKGROUND='green'

POWERLEVEL9K_SHORTEN_STRATEGY="truncate_middle"
POWERLEVEL9K_SHORTEN_DIR_LENGTH=4

POWERLEVEL9K_PROMPT_ON_NEWLINE=true

POWERLEVEL9K_MULTILINE_FIRST_PROMPT_PREFIX=''
POWERLEVEL9K_MULTILINE_SECOND_PROMPT_PREFIX="%F{red} \Uf1d0 %f %F{yellow}❯ "

POWERLEVEL9K_PROMPT_ON_NEWLINE=true
POWERLEVEL9K_RPROMPT_ON_NEWLINE=true

POWERLEVEL9K_STATUS_VERBOSE=false
POWERLEVEL9K_DIR_OMIT_FIRST_CHARACTER=false
POWERLEVEL9K_CONTEXT_ALWAYS_SHOW=true
POWERLEVEL9K_CONTEXT_ALWAYS_SHOW_USER=false

# Command prompt
POWERLEVEL9K_LEFT_PROMPT_ELEMENTS=(context dir_joined vcs custom_git_repo_name)
POWERLEVEL9K_RIGHT_PROMPT_ELEMENTS=(status anaconda root_indicator vi_mode date ssh)

# GitHub prompt
POWERLEVEL9K_VCS_GIT_GITHUB_ICON=$'\uF113'

get_repo_name() {
    if [[ $(git rev-parse --is-inside-work-tree 2>/dev/null) ]]; then
        # local repo_url=$(git remote show origin |grep URL |grep Fetch)
        # local url_end=$(echo $repo_url |awk -F'/' '{print $NF}')
        local url_end=$(git remote show origin |grep URL |grep Fetch |awk -F'\' '{print $NF}' |awk '{print $3}' |awk -F'\/' '{print $NF}' |awk -F'.' '{print $1}')
        # if [[ $(echo $url_end |egrep -e 'git$') ]]; then
            # local repo_name=$(echo $url_end |awk -F'.' '{print $1}')
        # else
            # local repo_name=$url_end
        # fi
        local repo_name=$url_end
    else
        local repo_name=''
    fi
    echo -n $repo_name
}

POWERLEVEL9K_CUSTOM_GIT_REPO_NAME="get_repo_name"

# dir
POWERLEVEL9K_SHORTEN_DIR_LENGTH=2
POWERLEVEL9K_SHORTEN_STRATEGY='truncate_to_first_and_last'

POWERLEVEL9K_STATUS_VERBOSE=true
POWERLEVEL9K_STATUS_CROSS=true

# anaconda segment
POWERLEVEL9K_ANACONDA_LEFT_DELIMITER="\uE235 "
POWERLEVEL9K_ANACONDA_RIGHT_DELIMITER=""
POWERLEVEL9K_ANACONDA_BACKGROUND='cyan'
POWERLEVEL9K_ANACONDA_FOREGROUND='black'

# dumb terminal can be a vim dump terminal in that case don't try to load plugins
# this block of commands was relocated to ${DOTFILES}/config_masters/zgen which is
# linked to ${HOME}/.zgen.conf
if [ ! $TERM = dumb ]; then
    ZGEN_DIR=${HOME}/.zgen
    source ${DOTFILES}/plugins/autojump/autojump.plugin.zsh
    source ${DOTFILES}/plugins/my-aliases/my-aliases.plugin.zsh
    source ${DOTFILES}/plugins/my-brew/my-brew.plugin.zsh
    source ${DOTFILES}/plugins/my-tmux/my-tmux.plugin.zsh
    source ${DOTFILES}/plugins/sudo/sudo.plugin.zsh
    source ${DOTFILES}/plugins/taskwarrior/taskwarrior.plugin.zsh
    source ${DOTFILES}/plugins/tmuxinator/tmuxinator.plugin.zsh
    source ${DOTFILES}/plugins/tpm/tpm.plugin.zsh
    source ${DOTFILES}/plugins/vi-mode/vi-mode.plugin.zsh
    source ${DOTFILES}/plugins/vundle/vundle.plugin.zsh
    source ${DOTFILES}/plugins/zsh-autosuggestions/zsh-autosuggestions.plugin.zsh
    source ${DOTFILES}/plugins/zsh-completions/zsh-completions.plugin.zsh
fi

# Which plugins would you like to load?
plugins=(sudo git my-tmux my-aliases taskwarrior tmux tmuxinator zsh-autosuggestions tpm)


test -e "${HOME}/.iterm2_shell_integration.zsh" && source "${HOME}/.iterm2_shell_integration.zsh"

# additional configuration for zsh
# Remove the history (fc -l) command from the history list when invoked.
setopt histnostore
# Remove superfluous blanks from each command line being added to the history list.
setopt histreduceblanks
# Do not exit on end-of-file. Require the use of exit or logout instead.
# setopt ignoreeof
# Print the exit value of programs with non-zero exit status.
setopt printexitvalue
# Do not share history
# setopt no_share_history

# load local tmux configurations
tmux source-file ~/.tmux-local.conf

# specific for machine configuration, which I don't sync
if [ -f ~/.machinerc ]; then
    source ~/.machinerc
fi

# Attempt to deduplicate the PATH variable
PATH="$(echo ${PATH} |sed 's/ /:/g')"
PATH="$(perl -e 'print join(":", grep { not $seen{$_}++ } split(/:/, $ENV{PATH}))')"

# if profiling was on
if $PROFILING; then
    zprof
fi

# zsh-syntax-highlighting must be sourced as the last thing in this file
source ~/.dotfiles/plugins/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh
if $DEBUG; then
    echo "zshrc> PATH: ${PATH}" >> ~/tmp/loginpaths.txt
    echo "zshrc> path: ${path}" >> ~/tmp/loginpaths.txt
    echo "zshrc> End of execution" >> ~/tmp/loginpaths.txt
    echo "-------------------------" >> ~/tmp/loginpaths.txt
fi
